From 0a6f52984ac194332298d95f15a829f95693179a Mon Sep 17 00:00:00 2001
From: Pauli Virtanen <pav@iki.fi>
Date: Sat, 24 Jul 2010 10:42:41 +0000
Subject: [PATCH 1/2] ENH: fix long double detection for linux ppc

This does not fix build on linux ppc, as the implementation for
long double functions is missing.

(cherry picked from commit r8510)
---
 numpy/core/setup.py                       |    3 ++-
 numpy/core/setup_common.py                |    4 ++++
 numpy/core/src/npymath/npy_math_private.h |    3 +++
 3 files changed, 9 insertions(+), 1 deletions(-)

diff --git a/numpy/core/setup.py b/numpy/core/setup.py
index c9ad982..0c82a55 100644
--- a/numpy/core/setup.py
+++ b/numpy/core/setup.py
@@ -428,7 +428,8 @@ def configuration(parent_package='',top_path=None):
                 if rep in ['INTEL_EXTENDED_12_BYTES_LE',
                            'INTEL_EXTENDED_16_BYTES_LE',
                            'IEEE_QUAD_LE', 'IEEE_QUAD_BE',
-                           'IEEE_DOUBLE_LE', 'IEEE_DOUBLE_BE']:
+                           'IEEE_DOUBLE_LE', 'IEEE_DOUBLE_BE',
+                           'DOUBLE_DOUBLE_BE']:
                     moredefs.append(('HAVE_LDOUBLE_%s' % rep, 1))
                 else:
                     raise ValueError("Unrecognized long double format: %s" % rep)
diff --git a/numpy/core/setup_common.py b/numpy/core/setup_common.py
index f361996..8356071 100644
--- a/numpy/core/setup_common.py
+++ b/numpy/core/setup_common.py
@@ -219,6 +219,8 @@ _INTEL_EXTENDED_16B = ['000', '000', '000', '000', '240', '242', '171', '353',
 _IEEE_QUAD_PREC_BE = ['300', '031', '326', '363', '105', '100', '000', '000',
                       '000', '000', '000', '000', '000', '000', '000', '000']
 _IEEE_QUAD_PREC_LE = _IEEE_QUAD_PREC_BE[::-1]
+_DOUBLE_DOUBLE_BE = ['301', '235', '157', '064', '124', '000', '000', '000'] + \
+                    ['000'] * 8
 
 def long_double_representation(lines):
     """Given a binary dump as given by GNU od -b, look for long double
@@ -254,6 +256,8 @@ def long_double_representation(lines):
                         return 'IEEE_QUAD_BE'
                     elif read[8:-8] == _IEEE_QUAD_PREC_LE:
                         return 'IEEE_QUAD_LE'
+                    elif read[8:-8] == _DOUBLE_DOUBLE_BE:
+                        return 'DOUBLE_DOUBLE_BE'
                 elif read[:16] == _BEFORE_SEQ:
                     if read[16:-8] == _IEEE_DOUBLE_LE:
                         return 'IEEE_DOUBLE_LE'
diff --git a/numpy/core/src/npymath/npy_math_private.h b/numpy/core/src/npymath/npy_math_private.h
index 5a63872..2f99101 100644
--- a/numpy/core/src/npymath/npy_math_private.h
+++ b/numpy/core/src/npymath/npy_math_private.h
@@ -363,6 +363,7 @@ do {                                                            \
     typedef npy_uint32 ldouble_sign_t;
 #endif
 
+#ifndef HAVE_LDOUBLE_DOUBLE_DOUBLE_BE
 /* Get the sign bit of x. x should be of type IEEEl2bitsrep */
 #define GET_LDOUBLE_SIGN(x) \
     (((x).a[LDBL_SIGN_INDEX] & LDBL_SIGN_MASK) >> LDBL_SIGN_SHIFT)
@@ -403,6 +404,8 @@ do {                                                            \
      ((x).a[LDBL_MANH_INDEX] & ~LDBL_MANH_MASK) |                       \
      (((IEEEl2bitsrep_part)(v) << LDBL_MANH_SHIFT) & LDBL_MANH_MASK))
 
+#endif /* #ifndef HAVE_LDOUBLE_DOUBLE_DOUBLE_BE */
+
 /*
  * Those unions are used to convert a pointer of npy_cdouble to native C99
  * complex or our own complex type independently on whether C99 complex
-- 
1.7.7.6

